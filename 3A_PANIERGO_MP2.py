# -*- coding: utf-8 -*-
"""3A_MOJER_MP2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/Mojerrrrrrrr/CSST-101-CS3A/blob/main/3A_MOJER_MP2.ipynb

# 1. Basic Operations
"""

def and_operation(p, q):
    """Logical conjunction (AND)."""
    return p and q

def or_operation(p, q):
    """Logical disjunction (OR)."""
    return p or q

def not_operation(p):
    """Logical negation (NOT)."""
    return not p

def implies_operation(p, q):
    """Logical implication (IMPLIES)."""
    return not p or q

"""# 2. Evaluate Logical Statements
To evaluate logical statements, we can create a function that parses a string representation of the logical expression and evaluates it based on the provided truth values.
"""

def evaluate(statement, values):
    """Evaluate a logical statement based on given truth values."""

    statement = statement.replace('AND', 'and').replace('OR', 'or').replace('NOT', 'not')
    statement = statement.replace('(', ' ( ').replace(')', ' ) ')

    tokens = statement.split()

    stack = []

    for token in tokens:
        if token in values:
            stack.append(values[token])
        elif token == 'not':
            stack.append(not stack.pop())
        elif token in ['and', 'or']:
            right = stack.pop()
            left = stack.pop()
            if token == 'and':
                stack.append(left and right)
            elif token == 'or':
                stack.append(left or right)
        else:
            raise ValueError(f"Unknown token: {token}")

    return stack[0] if stack else None

"""# Example Usage"""

def evaluate(statement, values):
    """Evaluate a logical statement based on given truth values."""

    statement = statement.replace('AND', ' and ').replace('OR', ' or ').replace('NOT', ' not ') # Add spaces around operators
    statement = statement.replace('(', '( ').replace(')', ' ) ')

    tokens = statement.split()

    stack = []

    for token in tokens:
        if token in values:
            stack.append(values[token])
        elif token == 'not':
            if stack: # Check if stack is not empty before popping
                stack.append(not stack.pop())
        elif token in ['and', 'or']:
            if len(stack) >= 2: # Check if there are enough operands
                right = stack.pop()
                left = stack.pop()
                if token == 'and':
                    stack.append(left and right)
                elif token == 'or':
                    stack.append(left or right)
        # Removed the else block as it was raising a ValueError for parentheses

    return stack[0] if stack else None

"""# Predicate Logic with Quantifiers
1. Universal Quantifier (∀)
The forall function checks if a given predicate holds true for all elements in a specified domain.
2. Existential Quantifier (∃)
The exists function checks if there is at least one element in the specified domain for which the predicate holds true.
Implementation
Here’s how you can implement these functions in Python:
"""

def forall(predicate, domain):
    """Evaluate the universal quantifier (FOR ALL)."""
    return all(predicate(x) for x in domain)

def exists(predicate, domain):
    """Evaluate the existential quantifier (EXISTS)."""
    return any(predicate(x) for x in domain)

"""# Example Usage of Quantifiers"""

# Define a predicate function
def is_even(x):
    """Predicate to check if a number is even."""
    return x % 2 == 0

def is_positive(x):
    """Predicate to check if a number is positive."""
    return x > 0

# Define a domain
domain = range(-5, 6)  # Numbers from -5 to 5

# Evaluate universal quantifier
all_even = forall(is_even, domain)  # Should return False
print(f"All numbers are even: {all_even}")

# Evaluate existential quantifier
any_even = exists(is_even, domain)  # Should return True
print(f"Any number is even: {any_even}")

# Evaluate universal quantifier for positive numbers
all_positive = forall(is_positive, domain)  # Should return False
print(f"All numbers are positive: {all_positive}")

# Evaluate existential quantifier for positive numbers
any_positive = exists(is_positive, domain)  # Should return True
print(f"Any number is positive: {any_positive}")

"""# Conclusion

The forall and exists functions allow you to evaluate predicate logic statements efficiently over a specified domain. You can define any predicate function that takes a single argument and returns a boolean value, enabling you to check various conditions across different sets of data. This setup provides a flexible way to work with predicate logic in Python.

# Scenario: Simple Game AI Agent
1. Define the Scenario

Let’s create a simple scenario where an AI agent is playing a turn-based game. The agent has two possible actions: "Attack" or "Defend." The decision to take one action over the other will depend on the following conditions:
If the agent's health is above 50%, it will "Attack."
If the agent's health is 50% or below, it will "Defend."
If the opponent's health is below 30%, the agent will "Attack" regardless of its own health.
2. Implementing the Decision Logic

We will use the logical functions we created earlier to implement this decision-making process.
"""

def and_operation(p, q):
    """Logical conjunction (AND)."""
    return p and q

def or_operation(p, q):
    """Logical disjunction (OR)."""
    return p or q

def not_operation(p):
    """Logical negation (NOT)."""
    return not p

def implies_operation(p, q):
    """Logical implication (IMPLIES)."""
    return not p or q

def evaluate(statement, values):
    """Evaluate a logical statement based on given truth values."""
    # Replace logical operators with Python equivalents
    statement = statement.replace('AND', 'and').replace('OR', 'or').replace('NOT', 'not')
    statement = statement.replace('(', ' ( ').replace(')', ' ) ')

    # Split the statement into tokens
    tokens = statement.split()

    # Evaluate the statement using a stack
    stack = []

    for token in tokens:
        if token in values:
            stack.append(values[token])
        elif token == 'not':
            stack.append(not stack.pop())
        elif token in ['and', 'or']:
            right = stack.pop()
            left = stack.pop()
            if token == 'and':
                stack.append(left and right)
            elif token == 'or':
                stack.append(left or right)
        else:
            raise ValueError(f"Unknown token: {token}")

    return stack[0] if stack else None

def forall(predicate, domain):
    """Evaluate the universal quantifier (FOR ALL)."""
    return all(predicate(x) for x in domain)

def exists(predicate, domain):
    """Evaluate the existential quantifier (EXISTS)."""
    return any(predicate(x) for x in domain)

class SimpleAIAgent:
    def __init__(self, health, opponent_health):
        self.health = health
        self.opponent_health = opponent_health

    def decide_action(self):
        """Decide whether to 'Attack' or 'Defend' based on health conditions."""
        # Define the decision logic
        attack_condition = (self.health > 50) or (self.opponent_health < 30)
        defend_condition = self.health <= 50

        # Use logical operations to determine action
        if and_operation(attack_condition, not_operation(defend_condition)):
            return "Attack"
        elif defend_condition:
            return "Defend"
        else:
            return "Attack"  # Default action if no other conditions met

"""# Explanation
1. Agent Initialization: The SimpleAIAgent class is initialized with health and opponent health.

2. Decision Logic: The decide_action method uses logical conditions to determine whether to "Attack" or "Defend":
It checks if the agent's health is greater than 50% or if the opponent's health is below 30%. If either condition is true, the agent chooses to "Attack."
If the agent's health is 50% or below, it will "Defend."

3. Example Usage: The agent's decisions are demonstrated with different health values.

## Conclusion
This simple AI agent uses logical reasoning to make decisions based on its health and the opponent's health. You can expand this model further by adding more complex conditions, additional actions, or even integrating it into a more extensive game framework. This approach provides a solid foundation for developing more sophisticated AI agents that rely on logical reasoning for decision-making.
"""